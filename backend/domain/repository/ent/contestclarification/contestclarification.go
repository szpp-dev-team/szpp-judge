// Code generated by ent, DO NOT EDIT.

package contestclarification

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the contestclarification type in the database.
	Label = "contest_clarification"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldContent holds the string denoting the content field in the database.
	FieldContent = "content"
	// FieldIsPublic holds the string denoting the is_public field in the database.
	FieldIsPublic = "is_public"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldAnswerContent holds the string denoting the answer_content field in the database.
	FieldAnswerContent = "answer_content"
	// FieldAnswerCreatedAt holds the string denoting the answer_created_at field in the database.
	FieldAnswerCreatedAt = "answer_created_at"
	// FieldAnswerUpdatedAt holds the string denoting the answer_updated_at field in the database.
	FieldAnswerUpdatedAt = "answer_updated_at"
	// EdgeContest holds the string denoting the contest edge name in mutations.
	EdgeContest = "contest"
	// EdgeTask holds the string denoting the task edge name in mutations.
	EdgeTask = "task"
	// EdgeUser holds the string denoting the user edge name in mutations.
	EdgeUser = "user"
	// EdgeAnswerUser holds the string denoting the answer_user edge name in mutations.
	EdgeAnswerUser = "answer_user"
	// Table holds the table name of the contestclarification in the database.
	Table = "contest_clarifications"
	// ContestTable is the table that holds the contest relation/edge. The primary key declared below.
	ContestTable = "contest_clarifications"
	// ContestInverseTable is the table name for the Contest entity.
	// It exists in this package in order to avoid circular dependency with the "contest" package.
	ContestInverseTable = "contests"
	// TaskTable is the table that holds the task relation/edge. The primary key declared below.
	TaskTable = "task_clarifications"
	// TaskInverseTable is the table name for the Task entity.
	// It exists in this package in order to avoid circular dependency with the "task" package.
	TaskInverseTable = "tasks"
	// UserTable is the table that holds the user relation/edge. The primary key declared below.
	UserTable = "user_clarifications"
	// UserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UserInverseTable = "users"
	// AnswerUserTable is the table that holds the answer_user relation/edge. The primary key declared below.
	AnswerUserTable = "user_answered_clarifications"
	// AnswerUserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	AnswerUserInverseTable = "users"
)

// Columns holds all SQL columns for contestclarification fields.
var Columns = []string{
	FieldID,
	FieldContent,
	FieldIsPublic,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldAnswerContent,
	FieldAnswerCreatedAt,
	FieldAnswerUpdatedAt,
}

var (
	// ContestPrimaryKey and ContestColumn2 are the table columns denoting the
	// primary key for the contest relation (M2M).
	ContestPrimaryKey = []string{"contest_id", "contest_clarification_id"}
	// TaskPrimaryKey and TaskColumn2 are the table columns denoting the
	// primary key for the task relation (M2M).
	TaskPrimaryKey = []string{"task_id", "contest_clarification_id"}
	// UserPrimaryKey and UserColumn2 are the table columns denoting the
	// primary key for the user relation (M2M).
	UserPrimaryKey = []string{"user_id", "contest_clarification_id"}
	// AnswerUserPrimaryKey and AnswerUserColumn2 are the table columns denoting the
	// primary key for the answer_user relation (M2M).
	AnswerUserPrimaryKey = []string{"user_id", "contest_clarification_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the ContestClarification queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByContent orders the results by the content field.
func ByContent(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldContent, opts...).ToFunc()
}

// ByIsPublic orders the results by the is_public field.
func ByIsPublic(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsPublic, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByAnswerContent orders the results by the answer_content field.
func ByAnswerContent(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAnswerContent, opts...).ToFunc()
}

// ByAnswerCreatedAt orders the results by the answer_created_at field.
func ByAnswerCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAnswerCreatedAt, opts...).ToFunc()
}

// ByAnswerUpdatedAt orders the results by the answer_updated_at field.
func ByAnswerUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAnswerUpdatedAt, opts...).ToFunc()
}

// ByContestCount orders the results by contest count.
func ByContestCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newContestStep(), opts...)
	}
}

// ByContest orders the results by contest terms.
func ByContest(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newContestStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTaskCount orders the results by task count.
func ByTaskCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTaskStep(), opts...)
	}
}

// ByTask orders the results by task terms.
func ByTask(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTaskStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUserCount orders the results by user count.
func ByUserCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUserStep(), opts...)
	}
}

// ByUser orders the results by user terms.
func ByUser(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAnswerUserCount orders the results by answer_user count.
func ByAnswerUserCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAnswerUserStep(), opts...)
	}
}

// ByAnswerUser orders the results by answer_user terms.
func ByAnswerUser(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAnswerUserStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newContestStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ContestInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, ContestTable, ContestPrimaryKey...),
	)
}
func newTaskStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TaskInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, TaskTable, TaskPrimaryKey...),
	)
}
func newUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, UserTable, UserPrimaryKey...),
	)
}
func newAnswerUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AnswerUserInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, AnswerUserTable, AnswerUserPrimaryKey...),
	)
}
