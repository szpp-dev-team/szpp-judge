package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"log/slog"
	"os"
	"reflect"
	"time"

	"github.com/szpp-dev-team/szpp-judge/langs"
	"github.com/tkrajina/typescriptify-golang-structs/typescriptify"
)

type CommandOption struct {
	out string
}

func parseArgs() CommandOption {
	o := CommandOption{}

	flag.StringVar(&o.out, "out", "./langs.ts", "File path to generate TypeScript code")

	flag.Parse()
	return o
}

type LangMetaBrief struct {
	Name   string `json:"name"`
	Active bool   `json:"active"`
}

type LangMetaFull struct {
	Name       string   `json:"name"`
	Active     bool     `json:"active"`
	SourceFile string   `json:"sourceFile"`
	CompileCmd []string `json:"compileCmd"`
	ExecCmd    []string `json:"execCmd"`
}

func writeFileHeadComment(w io.Writer) error {
	_, err := w.Write([]byte("// @generated by github.com/szpp-dev-team/szpp-judge/langs/cmd/gen\n"))
	if err != nil {
		return err
	}

	if err != nil {
		return err
	}

	fmt.Fprintf(w, "// @generated on %s\n", time.Now().Format(time.RFC1123Z))

	return nil
}

const INDENT = "  "

// 改行なしで v を JSON 書き込みする
func writeJSON(w io.WriteSeeker, e *json.Encoder, v any) error {
	if err := e.Encode(v); err != nil {
		return err
	}
	// json.Encoder は末尾に改行を追加するので現在位置から1文字分前へシークすることで改行文字を上書き
	if _, err := w.Seek(-1, 1); err != nil {
		return err
	}
	return nil
}

const TYPE_NAME_LANG_ID = "LangID"

func writeLangIDArray(w io.WriteSeeker, e *json.Encoder) error {
	const varName = "langIDs"

	langIDs := make([]langs.LangID, 0, len(langs.LangMetas))
	for i := range langs.LangMetas {
		langIDs = append(langIDs, langs.LangMetas[i].ID)
	}

	fmt.Fprintf(w, "\nexport const %s = ", varName)
	if err := writeJSON(w, e, langIDs); err != nil {
		return err
	}
	fmt.Fprintln(w, " as const;")
	fmt.Fprintf(w, "\nexport type %s = (typeof %s)[number];\n", TYPE_NAME_LANG_ID, varName)
	return nil
}

func newTypescriptify() *typescriptify.TypeScriptify {
	return typescriptify.
		New().
		WithIndent(INDENT).
		WithConstructor(false).
		WithInterface(true)
}

func writeLangMetasBrief(w io.WriteSeeker, e *json.Encoder) error {
	const varName = "langMetasBrief"
	var typ = reflect.TypeOf(LangMetaBrief{})

	v := map[langs.LangID]LangMetaBrief{}
	for i := range langs.LangMetas {
		m := &langs.LangMetas[i]
		v[m.ID] = LangMetaBrief{
			Name:   m.Name,
			Active: m.Active,
		}
	}

	s, err := newTypescriptify().AddType(typ).Convert(nil)
	if err != nil {
		return err
	}
	fmt.Fprintln(w, s)

	fmt.Fprintf(w, "\nexport const %s = ", varName)
	if err := writeJSON(w, e, v); err != nil {
		return err
	}
	fmt.Fprintln(w, " as const;")
	return nil
}

func writeLangMetasFull(w io.WriteSeeker, e *json.Encoder) error {
	const varName = "langMetasFull"
	var typ = reflect.TypeOf(LangMetaFull{})

	v := map[langs.LangID]LangMetaFull{}
	for i := range langs.LangMetas {
		m := &langs.LangMetas[i]
		v[m.ID] = LangMetaFull{
			Name:       m.Name,
			Active:     m.Active,
			SourceFile: m.SourceFile,
			CompileCmd: m.CompileCmd,
			ExecCmd:    m.ExecCmd,
		}
	}

	s, err := newTypescriptify().AddType(typ).Convert(nil)
	if err != nil {
		return err
	}
	fmt.Fprintln(w, s)

	fmt.Fprintf(w, "\nexport const %s = ", varName)
	if err := writeJSON(w, e, v); err != nil {
		return err
	}
	fmt.Fprintln(w, " as const;")
	return nil
}

func main() {
	opt := parseArgs()

	file, err := os.Create(opt.out)
	if err != nil {
		slog.Error("Cannot create file", slog.String("path", opt.out), slog.Any("err", err))
	}
	defer file.Close()

	jsonEncoder := json.NewEncoder(file)
	jsonEncoder.SetIndent("", INDENT)

	if err := writeFileHeadComment(file); err != nil {
		log.Fatal(err)
	}
	if err := writeLangIDArray(file, jsonEncoder); err != nil {
		log.Fatal(err)
	}
	if err := writeLangMetasBrief(file, jsonEncoder); err != nil {
		log.Fatal(err)
	}
	if err := writeLangMetasFull(file, jsonEncoder); err != nil {
		log.Fatal(err)
	}

	slog.Info("Successfully generated TypeScript file", slog.String("path", opt.out))
}
